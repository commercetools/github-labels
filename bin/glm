#!/usr/bin/env node

const mri = require('mri');
const axios = require('axios');
const fs = require('file-system');
require('dotenv').config();

const owner = process.env.OWNER;
const repo = process.env.REPOSITORY;
// eslint-disable-next-line dot-notation
axios.defaults.headers.common['Authorization'] = `token ${
  process.env.AUTH_TOKEN
}`;
// eslint-disable-next-line dot-notation
axios.defaults.headers.common['Accept'] =
  'application/vnd.github.symmetra-preview+json';

const flags = mri(process.argv.slice(2));
const commands = flags._;
const command = commands[0];

function printHelp() {
  console.log(`
  GITHUB LABEL MANAGER

    Usage: ./bin/glm [command] [option]

      Commands:
        init        Initializes the label manager. It creates a new label-config.json
                    file with the current label data of your repository.

        sync        Uploads all changes you've made in the label-config.json file
                    into the repository to update the label with the given changes.
  `);
}

function printMessage(message) {
  console.log(`
  GITHUB LABEL MANAGER...
    ${message}
  `);
}

(async () => {
  try {
    if (command === 'sync') {
      const summary = await labelControl();
      if (typeof summary === 'string') {
        printMessage(summary);
      }
      setTimeout(await writeLabelsConfig, 2000);
      if (typeof summary === 'object') {
        printMessage(`Labels synchronized!
      ${summary.created} created
      ${summary.deleted} deleted
      ${summary.updated} updated
        `);
      }
    } else if (command === 'init') {
      await writeLabelsConfig();
      printMessage('Labels successfully stored!');
    } else {
      printHelp();
    }
  } catch (err) {
    console.error(err);
    printHelp();
    process.exit(1);
  }
})();

function writeLabelsConfig() {
  return new Promise(async (resolve, reject) => {
    try {
      const labelData = await fetchLabels();
      const labels = await labelFormatter(labelData);
      fs.writeFile('./label-config.json', JSON.stringify(labels, null, 2));
      resolve();
    } catch (err) {
      reject(err);
    }
  });
}

function labelControl() {
  return new Promise(async (resolve, reject) => {
    try {
      const labelData = await fetchLabels();
      const formattedPublishedLabels = await labelFormatter(labelData);
      fs.readFile('./label-config.json', async (err, data) => {
        if (err) {
          throw err;
        }
        const localConfig = JSON.parse(data.toString());
        const newLabels = await checkForNewOrOldLabels(
          localConfig,
          formattedPublishedLabels
        );
        const labelsToDelete = await checkForNewOrOldLabels(
          formattedPublishedLabels,
          localConfig
        );
        const labelsToUpdate = await checkForModifications(
          localConfig,
          formattedPublishedLabels
        );
        if (newLabels.length !== 0) {
          await createLabels(newLabels);
        }
        if (labelsToDelete.length !== 0) {
          await deleteLabels(labelsToDelete);
        }
        if (labelsToUpdate.length !== 0) {
          await updateLabels(labelsToUpdate);
        }
        const changes =
          newLabels.length + labelsToDelete.length + labelsToUpdate.length;
        const summary =
          changes !== 0
            ? {
                created: newLabels.length,
                deleted: labelsToDelete.length,
                updated: labelsToUpdate.length,
              }
            : 'Labels already up to date!';
        resolve(summary);
      });
    } catch (err) {
      reject(err);
    }
  });
}

function checkForNewOrOldLabels(newLabels, oldLabels) {
  return new Promise((resolve, reject) => {
    try {
      const updatedLabels = [];
      const OldLabelIds = [];
      oldLabels.forEach(label => {
        OldLabelIds.push(label.id ? label.id : undefined);
      });
      newLabels.forEach(label => {
        if (!OldLabelIds.includes(label.id ? label.id : undefined)) {
          updatedLabels.push(label);
        }
      });
      resolve(updatedLabels);
    } catch (err) {
      reject(err);
    }
  });
}

function checkForModifications(localConfig, publishedConfig) {
  return new Promise(async (resolve, reject) => {
    const formattedPublishedConfig = await labelFormatter(publishedConfig);
    const labelChanges = [];
    try {
      localConfig.forEach(localLabel => {
        formattedPublishedConfig.forEach(publicLabel => {
          if (localLabel.id === publicLabel.id) {
            if (
              Object.values(localLabel).toString() !==
              Object.values(publicLabel).toString()
            ) {
              labelChanges.push(localLabel);
            }
          }
        });
      });
      resolve(labelChanges);
    } catch (err) {
      reject(err);
    }
  });
}

function labelFormatter(labelData) {
  return new Promise((resolve, reject) => {
    try {
      const formattedLabels = [];
      labelData.forEach(label => {
        const data = {
          id: label.id,
          name: label.name,
          color: label.color,
          description: label.description,
        };
        formattedLabels.push(data);
      });
      resolve(formattedLabels);
    } catch (err) {
      reject(err);
    }
  });
}

function fetchLabels() {
  const url = `https://api.github.com/repos/${owner}/${repo}/labels`;
  return axios.get(url).then(response => {
    const labels = [];
    response.data.forEach(label => {
      labels.push(label);
    });
    return labels;
  });
}

function createLabels(labels) {
  const url = `https://api.github.com/repos/${owner}/${repo}/labels`;
  labels.forEach(label => {
    const { name } = label;
    const { description } = label.description || '';
    const { color } = label.color || 'ededed';
    return axios
      .post(url, {
        name,
        description,
        color,
      })
      .catch(err => {
        console.log(err);
      });
  });
}

function deleteLabels(labels) {
  labels.forEach(label => {
    const url = `https://api.github.com/repos/${owner}/${repo}/labels/${
      label.name
    }`;
    return axios.delete(url).catch(err => {
      console.log(err);
    });
  });
}

async function updateLabels(labels) {
  const oldLabels = await fetchLabels();
  labels.forEach(label => {
    const requiredLabel = oldLabels.find(oldLabel => {
      return label.id === oldLabel.id ? oldLabel : undefined;
    });
    const url = `https://api.github.com/repos/${owner}/${repo}/labels/${
      requiredLabel.name
    }`;
    return axios.patch(url, {
      name: label.name || requiredLabel.name,
      description: label.description || requiredLabel.description,
      color: label.color || requiredLabel.color,
    });
  });
}
